# 리팩터링 1장: 첫 번째 예시

## 예제 요구사항

1. `JSON` 형식의 파일 데이터를 `text`와 `html` 형식의 문자열로 반환하는 간단한 프로그램을 작성하고 리팩터링해 보자.
2. 작은 단위로 작업할 때마다 `컴파일-테스트-커밋`을 수행한다.
3. 2번 요구사항을 충족하기 위해 테스트를 작성해야 한다.

---

## Kotlin으로 예제 작성

- 책의 `JavaScript` 예제를 `Kotlin`으로 변환
    - 최대한 책에 나와 있는 대로 작성한 후, 마지막에 내가 생각하는 `Kotlin` 스타일로 변경할 예정
- `JSON` 데이터를 적절한 객체로 변환
    - `Kotlin serializer`를 사용하여 `data class`로 변환
- `statement()` 함수에 대한 테스트 작성
    - `Kotest`를 활용하여 테스트 코드 작성

> 💡 책의 예제를 Kotlin으로 작성하는 것부터 쉽지 않았다.

---

## 1장의 느낀 점

1장의 예제를 작성하고 책을 따라 리팩터링을 진행하다 보면 익숙한 리팩터링 기법이 많이 나온다.  
예를 들어, `함수 쪼개기`, `변수 인라인`, `다형성 적용` 등이 있다. 아무래도 1장이다 보니 보편적으로 사용되는 리팩터링 기법이 소개된 듯하다.

책에서는 리팩터링을 시작하기 전에 테스트를 준비하고, 리팩터링을 진행할 때는 매우 작은 단위로 작업을 수행한다.  
개인적으로 이 부분이 매우 마음에 들었다. 작은 단위로 작업하고 커밋하는 습관을 기르기에 좋고, 테스트의 중요성도 깨달을 수 있기 때문이다.

추가적으로 책의 예제를 모두 작성한 후, 몇몇 부분을 내가 생각하는 Kotlin 스타일로 변경해 보았는데, 나쁘지 않은 경험이었다.  
아마 다른 챕터를 진행할 때도 마지막에 이 과정을 추가하게 될 것 같다.
---

## 의문과 해결

1장의 예제를 진행하면서 몇 가지 의문이 들었다.  
예를 들어, `중복 반복문`, `반복되는 호출` 등이었는데, 예제를 진행하면서 그 의문이 해결되었다.   
초반에 리팩터링으로 인한 성능 저하나 반복되어 보이는 코드는 신경 쓰지 않고 **관련된 코드를 모으는 작업이 중요하다는 것**을 깨달았다.

나는 개인적으로 리팩터링이 매우 어려운 작업이라고 생각했었다.  
오히려 새로운 기능을 만들거나 성능적인 이슈를 해결하는 작업보다도 어렵게 느꼈다.  
그 이유를 1장의 예제를 통해 알 수 있었다.  
나는 그동안 **모든 것을 한 번에 완벽히 리팩터링해야 한다**는 강박에 시달렸던 것 같다.

한 번의 리팩터링으로 코드를 간결하게 만들고, 성능을 유지하며, 읽기 쉬운 코드로 변환해야 한다고 생각했다.  
그러나 코드의 중복이 생기더라도, 혹은 성능 저하가 발생하더라도, 먼저 **관련된 코드를 모으고 구조를 만드는 것이 중요**했다는 것을 알게 되었다.

---

## 리팩터링 순서

리팩터링을 진행할 때의 순서에 대한 의문도 있었지만, 책을 통해 그 기준을 배울 수 있었다.  
물론 이 순서가 무조건 옳은 것은 아니겠지만, 순서를 정하는 기준이 생겼다는 점에서 만족스럽다.

### 리팩터링 순서

1. 테스트 작성 (기능 구현 시 작성된 테스트가 있다면 활용)
2. 지역 변수 없애기
3. 함수 쪼개기
4. 단계 쪼개기
5. 다형성 적용

앞으로 리팩터링을 진행할 때 위의 순서대로 시도해 보고, 나에게 맞는 방식을 찾아보려고 한다.

---

## AI와 리팩터링

현업에서 리팩터링이 필요한 경우, `AI`를 많이 활용하곤 했다.  
그러다 보니 리팩터링에 대한 실력이 늘지 않고 제자리였던 것 같다.  
가끔 이런 의문이 든다.

- "과연 사람이 읽기 좋은 코드가 계속 필요할까?"
- "리팩터링을 꼭 해야 하는 걸까?"

세상이 빠르게 변하다 보니 이런 생각이 들곤 한다.  
이 책을 통해 이 의문을 완전히 해소하기는 어렵겠지만, 부족한 부분을 메우는 기회로 삼아 완독해보려고 한다.
